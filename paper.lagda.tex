\documentclass{article}
\usepackage{hyperref}
\bibliographystyle{splncs04}
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{txfonts}
%\usepackage{bbm}
%\usepackage[greek,english]{babel}

% agda.sty wants to use the deprecated utf8x option, which
% many publishers don't like. So we do it ourselves

\usepackage{agda}

\usepackage{proof}

% this stuff is related to the Agda latex backend with inputenc/utf8
% not having heard of many charactersrs...

\usepackage{newunicodechar}
\newunicodechar{∋}{$\ni$}
% \newunicodechar{·}{$\cdot$}
\newunicodechar{⊢}{$\vdash$}
\newunicodechar{⋆}{${}^\star$}
\newunicodechar{Π}{$\Pi$}
\newunicodechar{⇒}{$\Rightarrow$}
\newunicodechar{ƛ}{$\lambdabar$}
\newunicodechar{∅}{$\emptyset$}
\newunicodechar{∀}{$\forall$}
\newunicodechar{ϕ}{$\Phi$}
\newunicodechar{ψ}{$\Psi$}
\newunicodechar{ρ}{$\rho$}
\newunicodechar{α}{$\alpha$}
\newunicodechar{β}{$\beta$}
\newunicodechar{μ}{$\mu$}
\newunicodechar{σ}{$\sigma$}
\newunicodechar{≡}{$\equiv$}
\newunicodechar{Γ}{$\Gamma$}
\newunicodechar{∥}{$\parallel$}
\newunicodechar{Λ}{$\Lambda$}
\newunicodechar{₁}{$~_0$}
\newunicodechar{₁}{$~_1$}
\newunicodechar{₂}{$~_2$}
\newunicodechar{θ}{$\theta$}
\newunicodechar{Θ}{$\Theta$}
\newunicodechar{∘}{$\circ$}
\newunicodechar{Δ}{$\Delta$}
\newunicodechar{λ}{$\lambda$}
\newunicodechar{⊧}{$\models$}
\newunicodechar{⊎}{$\uplus$}
\newunicodechar{η}{$\eta$}
\newunicodechar{⊥}{$\bot$}
\newunicodechar{Σ}{$\Sigma$}
\newunicodechar{ξ}{$\xi$}
\newunicodechar{ℕ}{$\mathbb{N}$}
\newunicodechar{ᶜ}{${}^c$}
\newunicodechar{Φ}{$\Phi$}
\newunicodechar{Ψ}{$\Psi$}
\newunicodechar{⊤}{$\top$}
\newunicodechar{≐}{$\doteq$}
\newunicodechar{≣}{$\triangleq$}
\newunicodechar{≃}{$\simeq$}
\newunicodechar{≅}{$\cong$}
\newunicodechar{∙}{$\bullet$}
\newunicodechar{ℓ}{$\ell$}
\newunicodechar{ℚ}{$\Q$}
\newunicodechar{ℤ}{$\Z$}
% \newunicodechar{}{$$}


\newunicodechar{∣}{\ensuremath{\mathnormal{\|}}}
\newunicodechar{∷}{\ensuremath{::}}



\usepackage{hyperref}
\usepackage{cleveref}

\author{Guilherme Horta Alvares da Silva}
% \email{guilhermehas@hotmail.com}
\title{Making all equalities equal}

\begin{document}

\AgdaHide{
\begin{code}
{-# OPTIONS --cubical --type-in-type #-}

module paper where

open import Agda.Primitive.Cubical
\end{code}
}


\maketitle

\begin{abstract}

\end{abstract}


\section{Equalities}

There are multiple ways of defining equalities in a theorem prover.
In the next sections, they will be defined.

\subsection{Martin-Löf Equality}

In the begin of Agda and in most theorems proves, the equality is given by Martin-Löf's definition:

\begin{code}
module Martin-Löf {ℓ} {A : Set ℓ} where

  data _≡_ (x : A) : A → Set ℓ where
    refl : x ≡ x
\end{code}

This equality is very covenient in proof assistances like Agda, because it is possible to pattern match using them:

\begin{code}
  private variable
    x y z : A

  sym  : x ≡ y → y ≡ x
  sym refl = refl

  trans : x ≡ y → y ≡ z → x ≡ z
  trans refl refl = refl
\end{code}

But the problem of this equality is that it does not handle extensionality and other axioms very well.

\begin{code}
module FunExt {ℓ ℓ'} {A : Set ℓ} {B : Set ℓ'} where
  open Martin-Löf

  funExt-Type = {f g : A → B}
    → ((x : A) → f x ≡ g x) → f ≡ g
\end{code}

\subsection{Cubical Equality}

To solve this problem, Agda adopted cubical type theory that equality is a function from path to types:

\begin{code}
module CubicalEquality {ℓ} {A : Set ℓ} where
  postulate
    PathP : (A : I → Set ℓ) → A i0 → A i1 → Set ℓ

  _≡_ : A → A → Set ℓ
  _≡_ = PathP λ _ → A
\end{code}

From this equality, I will define reflection, symmetry and extensionality:

\begin{code}
module CubicalResults {ℓ ℓ'} {A : Set ℓ} {B : Set ℓ'} where
  open import Cubical.Core.Primitives

  private variable
    x y z : A

  refl : x ≡ x
  refl {x = x} = λ _ → x

  sym : x ≡ y → y ≡ x
  sym p i = p (~ i)

  funExt : {f g : A → B}
    → ((x : A) → f x ≡ g x) → f ≡ g
  funExt p i x = p x i
\end{code}

The operator $\sim$ invert the interval. If the interval \AgdaBound{i} goes from
\AgdaBound{i0} to \AgdaBound{i1}, the interval $\sim i$ goes from \AgdaBound{i1} to \AgdaBound{i0}.

\subsection{Leibniz equality}

Leibniz equality is defined in this way:
If \AgdaBound{a} is equal to \AgdaBound{b}, then for every propositional \AgdaBound{P}, if \AgdaBound{P a},
then \AgdaBound{P b}.
The main idea is that if both values are equal, then they are seen equal for every angle.

\begin{code}
module LeibnizEquality {ℓ} {ℓ'} {A : Set ℓ} where
  _≐_ : A → A → Set
  a ≐ b = (P : A → Set ℓ') → P a → P b
\end{code}

\section{Joining all equalities}

All equalities have something in common. They are all equal to each other.
So it will be defined a common record that all equalities should have.
In the next defintion, all equalities are equal to the cubical equality:

\begin{code}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Univalence
open import Cubical.Foundations.Function
open import Cubical.Data.Equality

module _ {a ℓ} {A : Set a} where
  ≣-Type = A → A → Set ℓ

  record IsEquality (_≣_ : ≣-Type) : Set (ℓ-suc (ℓ-max a ℓ)) where
    constructor eq
    field
      ≣-≡-≡ : ∀ {x y} → let
        ℓ₁ = ℓ-max a ℓ

        x≡y : Type ℓ₁
        x≡y = x ≡ y

        x≣y : Type ℓ₁
        x≣y = x ≣ y

        in _≡_ {ℓ-suc ℓ₁} x≣y x≡y

  record Equality : Set (ℓ-suc (ℓ-max a ℓ)) where
    field
      _≣_ : ≣-Type
      isEquality : IsEquality _≣_
\end{code}

It will be defined for each equality, its instance:

\begin{code}
module _ {a} {A : Set a} where
  instance
    ≡-IsEquality : IsEquality {A = A} _≡_
    ≡-IsEquality = eq refl

  instance
    ≡p-IsEquality : IsEquality {A = A} _≡p_
    ≡p-IsEquality = eq (λ {x y} → sym λ i → p-c {x = x} {y = y} i)


module _ {ℓ} where
  univalencePath' : {A B : Type ℓ} → (A ≡ B) ≡ (A ≃ B)
  univalencePath' {A} {B} =
    ua {ℓ-suc ℓ} {A ≡ B} {A ≃ B} (compEquiv (univalence {ℓ} {A} {B})
    (isoToEquiv (iso {ℓ} {ℓ-suc ℓ} (λ x → x) (λ x → x) (λ b i → b) λ a i → a)))

  instance
    ≃-IsEquality : IsEquality {A = Type ℓ} (λ A B → (A ≃ B))
    ≃-IsEquality = eq λ {A B} → sym λ i → univalencePath' {A = A} {B = B} i

liftIso : ∀ {a b} {A : Type a} {B : Type b} → Iso {a} {b} A B → Iso {ℓ-max a b} {ℓ-max a b} A B
liftIso {a} f = iso fun inv (λ x i → rightInv x i) (λ x i → leftInv x i)
  where open Iso f

open import leibniz
open Leibniz

module FinalEquality {A : Set} where
  open MainResult A

  ≐≅≡ : ∀ {a b} → Iso (a ≐ b) (a ≡p b)
  ≐≅≡ = iso j i (ptoc ∘ ji) (ptoc ∘ ij)

  ≐≡≡' : ∀ {a b} → (a ≐ b) ≡c (a ≡p b)
  ≐≡≡' = let lifted = liftIso ≐≅≡  in isoToPath lifted

  ≐≡≡ : _≐_ {A} ≡c _≡p_
  ≐≡≡ i x y = ≐≡≡' {x} {y} i

  open IsEquality

  instance
    ≐-IsEquality : IsEquality {A = A} _≐_
    ≐-IsEquality = eq λ {x} {y} → ≐≡≡' ∙ λ i → ≡p-IsEquality {ℓ-zero} .≣-≡-≡ {x} {y} i
\end{code}



\section*{Acknowledgements}


\bibliography{bibliography}
\end{document}
