\documentclass{article}
\usepackage{hyperref}
\bibliographystyle{splncs04}
%\usepackage{ucs}
\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{txfonts}
%\usepackage{bbm}
%\usepackage[greek,english]{babel}

% agda.sty wants to use the deprecated utf8x option, which
% many publishers don't like. So we do it ourselves

\usepackage{agda}

\usepackage{proof}

% this stuff is related to the Agda latex backend with inputenc/utf8
% not having heard of many charactersrs...

\usepackage{newunicodechar}
\newunicodechar{∋}{$\ni$}
% \newunicodechar{·}{$\cdot$}
\newunicodechar{⊢}{$\vdash$}
\newunicodechar{⋆}{${}^\star$}
\newunicodechar{Π}{$\Pi$}
\newunicodechar{⇒}{$\Rightarrow$}
\newunicodechar{ƛ}{$\lambdabar$}
\newunicodechar{∅}{$\emptyset$}
\newunicodechar{∀}{$\forall$}
\newunicodechar{ϕ}{$\Phi$}
\newunicodechar{ψ}{$\Psi$}
\newunicodechar{ρ}{$\rho$}
\newunicodechar{α}{$\alpha$}
\newunicodechar{β}{$\beta$}
\newunicodechar{μ}{$\mu$}
\newunicodechar{σ}{$\sigma$}
\newunicodechar{≡}{$\equiv$}
\newunicodechar{Γ}{$\Gamma$}
\newunicodechar{∥}{$\parallel$}
\newunicodechar{Λ}{$\Lambda$}
\newunicodechar{₁}{$~_0$}
\newunicodechar{₁}{$~_1$}
\newunicodechar{₂}{$~_2$}
\newunicodechar{₃}{$~_3$}
\newunicodechar{θ}{$\theta$}
\newunicodechar{Θ}{$\Theta$}
\newunicodechar{∘}{$\circ$}
\newunicodechar{Δ}{$\Delta$}
\newunicodechar{λ}{$\lambda$}
\newunicodechar{⊧}{$\models$}
\newunicodechar{⊎}{$\uplus$}
\newunicodechar{η}{$\eta$}
\newunicodechar{⊥}{$\bot$}
\newunicodechar{Σ}{$\Sigma$}
\newunicodechar{ξ}{$\xi$}
\newunicodechar{ℕ}{$\mathbb{N}$}
\newunicodechar{ᶜ}{${}^c$}
\newunicodechar{Φ}{$\Phi$}
\newunicodechar{Ψ}{$\Psi$}
\newunicodechar{⊤}{$\top$}
\newunicodechar{≐}{$\doteq$}
\newunicodechar{≣}{$\triangleq$}
\newunicodechar{≃}{$\simeq$}
\newunicodechar{≅}{$\cong$}
\newunicodechar{∙}{$\bullet$}
\newunicodechar{ℓ}{$\ell$}
\newunicodechar{ℚ}{$\Q$}
\newunicodechar{ℤ}{$\Z$}
\newunicodechar{⦃}{$\{$}
\newunicodechar{⦄}{$\}$}
% \newunicodechar{}{$$}


\newunicodechar{∣}{\ensuremath{\mathnormal{\|}}}
\newunicodechar{∷}{\ensuremath{::}}



\usepackage{hyperref}
\usepackage{cleveref}

\author{Guilherme Horta Alvares da Silva}
% \email{guilhermehas@hotmail.com}
\title{Making all equalities equal}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}


\section{Equalities}

There are multiple ways of defining equalities in a theorem prover.
In the next sections, they will be defined.

\subsection{Imports}

First, it will be necessary to give some agda arguments:

\begin{code}
{-# OPTIONS --cubical --cumulativity #-}
module paper where
\end{code}

The cubical flag is necessary because we are using cubical equality,
and the cumulativiy flag is also necessary for level subtyping,

\begin{code}
open import Agda.Primitive.Cubical using (I; i0; i1)
\end{code}

This library loads Cubical Agda Primitives as the equality interval.

\subsection{Martin-Löf Equality}

At the begin of Agda and in most theorems proves, equality is given by Martin-Löf's definition:

\begin{code}
module Martin-Löf {ℓ} {A : Set ℓ} where

  data _≡_ (x : A) : A → Set ℓ where
    refl : x ≡ x
\end{code}

This equality is very convenient in proof assistances like Agda because it is possible to pattern match using them:

\begin{code}
  private variable
    x y z : A

  sym  : x ≡ y → y ≡ x
  sym refl = refl

  trans : x ≡ y → y ≡ z → x ≡ z
  trans refl refl = refl
\end{code}

But the problem of this equality is that it does not handle extensionality and other axioms very well.

\begin{code}
module FunExt {ℓ ℓ'} {A : Set ℓ} {B : Set ℓ'} where
  open Martin-Löf

  funExt-Type = {f g : A → B}
    → ((x : A) → f x ≡ g x) → f ≡ g
\end{code}

\subsection{Cubical Equality}

To solve this problem, Agda adopted cubical type theory that equality is a function from the path to type:

\begin{code}
module CubicalEquality {ℓ} {A : Set ℓ} where
  postulate
    PathP : (A : I → Set ℓ) → A i0 → A i1 → Set ℓ

  _≡_ : A → A → Set ℓ
  _≡_ = PathP λ _ → A
\end{code}

From this equality, I will define reflection, symmetry and extensionality:

\begin{code}
module CubicalResults {ℓ ℓ'} {A : Set ℓ} {B : Set ℓ'} where
  open import Cubical.Core.Primitives

  private variable
    x y z : A

  refl : x ≡ x
  refl {x = x} = λ _ → x

  sym : x ≡ y → y ≡ x
  sym p i = p (~ i)

  funExt : {f g : A → B}
    → ((x : A) → f x ≡ g x) → f ≡ g
  funExt p i x = p x i
\end{code}

The operator $\sim$ invert the interval. If the interval \AgdaBound{i} goes from
\AgdaBound{i0} to \AgdaBound{i1}, the interval $\sim i$ goes from \AgdaBound{i1} to \AgdaBound{i0}.

\subsection{Leibniz equality}

Leibniz equality is defined in this way:
If \AgdaBound{a} is equal to \AgdaBound{b}, then for every propositional \AgdaBound{P}, if \AgdaBound{P a},
then \AgdaBound{P b}.
The main idea is that if both values are equal, then they are seen equal for every angle.

\begin{code}
module LeibnizEquality {A : Set} where
  _≐_ : A → A → Set₁
  a ≐ b = (P : A → Set) → P a → P b
\end{code}

\section{Joining all equalities}

All equalities have something in common. They are all equal to each other.
So it will be defined as a common record that all equalities should have.
In the next definition, all equalities are equal to cubical equality:

\begin{code}

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Univalence
open import Cubical.Foundations.Function
open import Cubical.Data.Equality

module _ {a ℓ} {A : Set a} where
  ≣-Type = A → A → Set ℓ

  record IsEquality (_≣_ : ≣-Type) : Set (ℓ-suc (ℓ-max a ℓ)) where
    constructor eq
    field
      ≣-≡-≡ : ∀ {x y} → let
        ℓ₁ = ℓ-max a ℓ

        x≡y : Type ℓ₁
        x≡y = x ≡ y

        x≣y : Type ℓ₁
        x≣y = x ≣ y

        in _≡_ {ℓ-suc ℓ₁} x≣y x≡y

    ≡-≡-≣ : {x y : A} → let
      x≡y : Type (ℓ-max a ℓ)
      x≡y = x ≡ y
      x≣y = x ≣ y
      in x≡y ≡ x≣y
    ≡-≡-≣ = sym ≣-≡-≡

  module _ {_≣_ : ≣-Type} where
    sym-Equality : (≡-≡-≣ : {x y : A} → let
      x≡y : Type (ℓ-max a ℓ)
      x≡y = x ≡ y
      x≣y = x ≣ y
      in x≡y ≡ x≣y)
      → IsEquality _≣_
    sym-Equality ≡-≡-≣ = eq (sym ≡-≡-≣)

  record Equality : Set (ℓ-suc (ℓ-max a ℓ)) where
    field
      _≣_ : ≣-Type
      isEquality : IsEquality _≣_
\end{code}

It will be defined for each equality, its instance:

\subsection{Cubical Equality}

The simplest example is the cubical equality hence this equality is already equal to itself.

\begin{code}
module _ {a} {A : Set a} where
  instance
    ≡-IsEquality : IsEquality {A = A} _≡_
    ≡-IsEquality = eq refl
\end{code}

\subsection{Martin-Löf equality}

The proof of Martin-Löf equality is more difficult, but it is already in Cubical library as \AgdaFunction{p-c}.

\begin{code}
  instance
    ≡p-IsEquality : IsEquality {A = A} _≡p_
    ≡p-IsEquality = sym-Equality (λ {x y} → λ i → p-c {x = x} {y = y} i)
\end{code}

\subsection{Isomorphism}

The isomorphism is an equality between types.

\begin{code}
module _ {ℓ} where
  univalencePath' : {A B : Type ℓ} → (A ≡ B) ≡ (A ≃ B)
  univalencePath' {A} {B} =
    ua {ℓ-suc ℓ} {A ≡ B} {A ≃ B} (compEquiv (univalence {ℓ} {A} {B})
    (isoToEquiv (iso {ℓ} {ℓ-suc ℓ}
    (λ x → x) (λ x → x) (λ b i → b) λ a i → a)))
\end{code}

\AgdaFunction{univalencePath} is already defined in Agda library, but with \AgdaBound{A ≃ B} instead of
\AgdaBound{Lifted (A ≃ B)}. This change can be done because of the cumulativity flag.

\begin{code}
  instance
    ≃-IsEquality : IsEquality
      {A = Type ℓ} _≃_
    ≃-IsEquality = sym-Equality λ {A B} →
      λ i → univalencePath' {A = A} {B = B} i
\end{code}

\subsection{Leibniz Equality}

The hardest equality to proof that is equalty is the Leibniz Equality.

\begin{code}
liftIso : ∀ {a b} {A : Type a} {B : Type b}
  → Iso {a} {b} A B → Iso {ℓ-max a b} {ℓ-max a b} A B
liftIso {a} f = iso fun inv
  (λ x i → rightInv x i) (λ x i → leftInv x i)
\end{code}

This \AgdaFunction{liftIso} will be used to lift the Isomorphism to types of the same maximum level of both.

\begin{code}
  where open Iso f

open import leibniz
open Leibniz
\end{code}

It is importing the definition of Leibniz equality made by \cite{abel2020leibniz}.
In this work, there is already a proof of the isomorphism between the Leibniz and the Martin-Löf equality.

\begin{code}
module FinalEquality {A : Set} where
  open MainResult A

  ≐≅≡ : ∀ {a b} → Iso (a ≐ b) (a ≡p b)
  ≐≅≡ = iso j i (ptoc ∘ ji) (ptoc ∘ ij)
\end{code}

In Cubical Library, the definition of isomorphism uses cubical equality instead of Martin-Löf equality
when we have to proof that \AgdaBound{∀ x → from (to x) ≡ x} and \AgdaBound{∀ x → to (from x) ≡ x}.
\AgdaFunction{ptoc} is necessary to do this convertion from these equalities.

\begin{code}
  ≐≡≡ : ∀ {a b} → (a ≐ b) ≡c (a ≡p b)
  ≐≡≡ = let lifted = liftIso ≐≅≡  in isoToPath lifted
\end{code}

Using the univalence and \AgdaFunction{liftIso} defined previously, it is possible to transform the isormorphism
into an equality.

\begin{code}
  open IsEquality

  instance
    ≐-IsEquality : IsEquality {A = A} _≐_
    ≐-IsEquality = eq λ {x} {y} → ≐≡≡ ∙
      λ i → ≡p-IsEquality {ℓ-zero} .≣-≡-≡ {x} {y} i
\end{code}

The last pass is to join the three equalities between equalities:
Leibniz to Martin-Löf to cubical equality.

\begin{code}
module Equalities {a ℓ} {A : Set a} where
  ≣-Type' = ≣-Type {a} {ℓ} {A}

  module _
    (_≡₁_ : ≣-Type')
    (_≡₂_ : ≣-Type')
    ⦃ eq₁ : IsEquality {a} {ℓ} _≡₁_ ⦄
    ⦃ eq₂ : IsEquality _≡₂_ ⦄
    where

    ℓ₁ = ℓ-max a ℓ

    record IsEquality₂ (_≣_ : ≣-Type') : Set (ℓ-suc (ℓ-max a ℓ)) where
      constructor eq
      field
        ≣-≡-≡ : ∀ {x y} → let
          x≡y : Type ℓ₁
          x≡y = x ≡₁ y

          x≣y : Type ℓ₁
          x≣y = x ≣ y

          in _≡_ {ℓ-suc ℓ₁} x≣y x≡y

      ≡-≡-≣ : {x y : A} → let
        x≡y : Type ℓ₁
        x≡y = x ≡₁ y
        x≣y = x ≣ y
        in x≡y ≡ x≣y
      ≡-≡-≣ = sym ≣-≡-≡

      instance
        isEquality : IsEquality _≣_
        isEquality = eq (≣-≡-≡ ∙ IsEquality.≣-≡-≡ eq₁)

    instance
      ≡₂-Equality₂ : IsEquality₂ _≡₂_
      ≡₂-Equality₂ = eq (eq₂ .≣-≡-≡ ∙ sym (eq₁ .≣-≡-≡))
        where open IsEquality

    alwaysEqual : ∀ {x y} →  x ≡₁ y → x ≡₂ y
    alwaysEqual {x} {y} p =
      let joined = sym (≣-≡-≡ {x} {y})
      in transport joined p
      where open IsEquality₂ ≡₂-Equality₂

    module _ {_≣_ : ≣-Type} where
      sym-Equality₂ : (≡-≡-≣ : {x y : A} → let
        x≡y : Type (ℓ-max a ℓ)
        x≡y = x ≡₁ y
        x≣y = x ≣ y
        in x≡y ≡ x≣y)
        → IsEquality₂ _≣_
      sym-Equality₂ ≡-≡-≣ = eq (sym ≡-≡-≣)

    module _
      (_≡₃_ : ≣-Type {ℓ-suc ℓ₁} {a})
      ⦃ eq₃ : IsEquality _≡₃_ ⦄
      where

      record IsEquality₃ (_≣_ : ≣-Type') : Set (ℓ-suc (ℓ-max a ℓ)) where
        constructor eq
        field
          ≣-≡-≡ : ∀ {x y} → let
            x≡y : Type ℓ₁
            x≡y = x ≡₁ y

            x≣y : Type ℓ₁
            x≣y = x ≣ y

            in x≣y ≡₃ x≡y

        instance
          isEquality₂ : IsEquality₂ _≣_
          isEquality₂ = eq (transport (IsEquality.≣-≡-≡ eq₃) ≣-≡-≡)

          isEquality : IsEquality _≣_
          isEquality = eq (IsEquality₂.≣-≡-≡ isEquality₂ ∙ IsEquality.≣-≡-≡ eq₁)

        ≡-≡-≣ : {x y : A} → let
          x≡y : Type ℓ₁
          x≡y = x ≡₁ y
          x≣y = x ≣ y
          in x≡y ≡₃ x≣y
        ≡-≡-≣ = let
          α₁ = IsEquality.≡-≡-≣ eq₃
          α₂ = IsEquality.≣-≡-≡ eq₁
          α₃ = IsEquality.≡-≡-≣ isEquality
          in transport α₁ (α₂ ∙ α₃)

      instance
        ≡₂-Equality₃ : IsEquality₃ _≡₂_
        ≡₂-Equality₃ = eq α
          where
            open IsEquality eq₃
            α : ∀ {x y} → (x ≡₂ y) ≡₃ (x ≡₁ y)
            α = transport ≡-≡-≣ (IsEquality₂.≣-≡-≡ ≡₂-Equality₂)

      module _ {_≣_ : ≣-Type'} where
        sym-Equality₃ : (≡-≡-≣ : {x y : A} → let
          x≡y : Type (ℓ-max a ℓ)
          x≡y = x ≡₁ y
          x≣y = x ≣ y
          in x≡y ≡₃ x≣y)
          → IsEquality₃ _≣_
        sym-Equality₃ ≡-≡-≣ = eq (let
          α₁ = IsEquality.≡-≡-≣ eq₃
          α₂ = transport (sym α₁) ≡-≡-≣
          in transport α₁ (sym α₂))


\end{code}

\section*{Acknowledgements}


\bibliography{bibliography}
\end{document}
